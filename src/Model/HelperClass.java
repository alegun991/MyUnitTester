package Model;
import se.umu.cs.unittest.TestClass;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;

public class HelperClass {

    private Class<?> aClass;
    private Method[] methods;
    private ArrayList<String> testResult;
    private String className;
    private int setUpIndex;
    private int tearDownIndex;
    private int successCount = 0;
    private int failCount = 0;
    private int exceptionCount = 0;
    private ArrayList<String> error;
    private boolean isError = false;


    public HelperClass(String className) {
        this.className = className;
        testResult = new ArrayList<>();
        error = new ArrayList<>();
        aClass = getClassForName();

    }

    /**
     * Looks for setUp method, if found saves the index for that method.
     *
     * @return returns true if setup method is found and has correct parameters
     */
    private boolean hasSetUp() {
        for (int i = 0; i < methods.length; i++) {

            if (methods[i].getName().equals("setUp")
                    && methods[i].getParameterCount() == 0) {

                setUpIndex = i;
                return true;
            }
        }
        return false;
    }

    /**
     * Looks for tearDown method, if found saves the index for that method.
     *
     * @return returns true if setup method is found and has correct parameters
     */
    private boolean hasTearDown() {
        for (int i = 0; i < methods.length; i++) {

            if (methods[i].getName().equals("tearDown")
                    && methods[i].getParameterCount() == 0) {
                tearDownIndex = i;
                return true;
            }
        }
        return false;
    }

    public ArrayList<String> invokeMethod(Object obj) {

        boolean success;
        methods = aClass.getMethods();

        ArrayList<Method> testMethods = validTestMethods();
        if (testMethods.isEmpty()) {
            isError = true;
            return error;
        }

        for (Method m : testMethods) {
            try {
                if (hasSetUp()) {
                    methods[setUpIndex].invoke(obj);
                }

                success = (boolean) m.invoke(obj);

                if (success) {
                    testResult.add(m.getName() + ": SUCCESS \n");
                    successCount++;
                } else {
                    testResult.add(m.getName() + ": FAIL \n");
                    failCount++;
                }

                if (hasTearDown()) {
                    methods[tearDownIndex].invoke(obj);
                }
            } catch (IllegalAccessException | InvocationTargetException e) {
                exceptionCount++;
                testResult.add(m.getName() + ":" + " FAIL generated by a "
                        + e.getCause().toString() + "\n");
            }
        }
        addSummary(successCount, failCount, exceptionCount);
        return testResult;
    }

    public boolean validateClass(Class<?> cls) {

        if (cls.isInterface()) {
            error.add("Class is interface, cannot be instantiated! \n");
            isError = true;
        }

        if (!TestClass.class.isAssignableFrom(aClass)) {
            error.add("Class does not implement TestClass \n");
            isError = true;
        }
        Constructor[] constructors = cls.getDeclaredConstructors();
        for (Constructor c : constructors) {

            if (c.getParameterCount() != 0) {
                error.add("Class does not have empty constructor! \n");
                isError = true;
            }
        }

        return isError;
    }

    private ArrayList<Method> validTestMethods() {
        ArrayList<Method> testMethods = new ArrayList<>();
        for (Method m : methods) {

            if (m.getName().startsWith("test")
                    && (m.getReturnType() == boolean.class) &&
                    m.getParameterCount() == 0) {

                testMethods.add(m);
            }
        }

        if (testMethods.isEmpty()) {
            error.add("Class does not contain valid test methods \n");
        }

        return testMethods;
    }

    public Class<?> getClassForName() {

        try {
            return Class.forName(className);

        } catch (ClassNotFoundException e) {
            isError = true;
            error.add("Class not found! \n");
            return null;
        }

    }

    Class getClassObject() {

        if (aClass == null) {

            return null;
        } else {

            return aClass;
        }
    }

    public Object instantiateClass() {
        Object obj = null;

        try {

            obj = aClass.getDeclaredConstructor().newInstance();

        } catch (InstantiationException | NoSuchMethodException
                | IllegalAccessException e) {

            isError = true;
            error.add("Could not instantiate class \n");

        } catch (InvocationTargetException e) {
            isError = true;
            error.add("Class threw: " + e.getCause().toString() + "\n");
        }

        return obj;

    }

    private void addSummary(int success, int fail, int exception) {

        testResult.add("\n" + success + " tests succeeded \n" +
                fail + " tests failed \n" +
                exception + " failed because of an exception \n");
    }

    ArrayList<String> getError() {
        return error;
    }

    boolean isError() {
        return isError;
    }
}

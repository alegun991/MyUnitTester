package Model;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;

class HelperClass {

    private Class<?> aClass;
    private Method[] methods;
    private ArrayList<String> testResult;
    private String className;
    private int setUpIndex;
    private int tearDownIndex;
    private int successCount = 0;
    private int failCount = 0;
    private int exceptionCount = 0;
    private ArrayList<String> error;
    private boolean isError = false;


    HelperClass(String className) {
        this.className = className;
        testResult = new ArrayList<>();
        error = new ArrayList<>();
        aClass = getClassForName();

    }

    /**
     * Looks for setUp method, if found saves the index for that method.
     *
     * @return returns true if setup method is found and has correct parameters
     */
    private boolean hasSetUp() {
        for (int i = 0; i < methods.length; i++) {

            if (methods[i].getName().equals("setUp") && methods[i].getParameterCount() == 0) {
                setUpIndex = i;
                return true;
            }
        }
        return false;
    }

    /**
     * Looks for tearDown method, if found saves the index for that method.
     *
     * @return returns true if setup method is found and has correct parameters
     */
    private boolean hasTearDown() {
        for (int i = 0; i < methods.length; i++) {

            if (methods[i].getName().equals("tearDown") && methods[i].getParameterCount() == 0) {
                tearDownIndex = i;
                return true;
            }
        }
        return false;
    }

    public ArrayList<String> invokeMethod(Object obj) {

        boolean success;
        methods = aClass.getMethods();

        ArrayList<Method> testMethods = validTestMethods();
        for (Method m : testMethods) {
            try {
                if (hasSetUp()) {
                    methods[setUpIndex].invoke(obj);
                }

                success = (boolean) m.invoke(obj);

                if (success) {
                    testResult.add(m.getName() + ": SUCCESS \n");
                    successCount++;
                } else {
                    testResult.add(m.getName() + ": FAIL \n");
                    failCount++;
                }

                if (hasTearDown()) {
                    methods[tearDownIndex].invoke(obj);
                }
            } catch (IllegalAccessException | InvocationTargetException e) {
                exceptionCount++;
                testResult.add(m.getName() + ":" + " FAIL generated by a " + e.getCause().toString() +"\n");
            }
        }
        addSummary(successCount, failCount, exceptionCount);
        return testResult;
    }

    public void validateClass(Class<?> cls){

        if(cls.isInterface()){
            error.add("Class is interface, cannot be instantiated! \n");
            isError = true;
        }

        Class[] interfaces = cls.getInterfaces();
        for (Class c : interfaces){

            if(!c.getName().equals("se.umu.cs.unittest.TestClass")){

                error.add("Class does not implement TestClass interface! \n");
                isError = true;
            }
        }
        Constructor[] constructors = cls.getConstructors();
        for (Constructor c : constructors){

            if (c.getParameterCount() != 0) {
                error.add("Class does not have empty constructor! \n");
                isError = true;
                break;
            }
        }

    }

    private ArrayList<Method> validTestMethods(){
        ArrayList<Method> testMethods = new ArrayList<>();
        for(Method m : methods){

            if (m.getName().startsWith("test") && (m.getReturnType() == boolean.class) &&
            m.getParameterCount() == 0){
                testMethods.add(m);

            }
        }
        return testMethods;
    }

    public Class<?> getClassForName(){

        try {
            return Class.forName(className);

        } catch (ClassNotFoundException e) {
            isError = true;
            error.add("Class not found! \n");
            return null;
        }

    }

    public Class getClassObject(){

        if(aClass == null){

            return null;
        }
        else{

            return aClass;
        }
    }

    public Object instantiateClass(){
        Object obj = null;
        try {
            obj = aClass.getConstructor().newInstance();
        } catch (InstantiationException | NoSuchMethodException | IllegalAccessException e) {
            isError = true;
            error.add("Could not instantiate class \n");
        } catch (InvocationTargetException e) {
            isError = true;
            error.add("Class threw: " + e.getCause().toString() + "\n");
        }

        return obj;

    }

    private void addSummary(int success, int fail, int exception){

        testResult.add("\n" + success + " tests suceeded \n" +
                fail + " tests failed \n" +
                exception + " failed because of an exception");
    }

    public ArrayList<String> getError(){
        return error;
    }

    public boolean isError() {
        return isError;
    }
}
